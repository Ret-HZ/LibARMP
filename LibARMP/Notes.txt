LibARMP / dbedit Notes:


- A column being marked invalid shouldn't delete its data.

	- If I mark a column invalid and its data is deleted, why wouldn't I just delete the column altogether?
		I'd think that I'd only mark a column invalid if I still want to retain it, which means the data is still potentially valuable.
		(I imagine the column greyed out but with the data still present, maybe even still editable.)

	- One example use case would be columns that I sometimes mark valid prior to export for debug purposes.
		I'd want them to still contain data, I wouldn't want to have to reinitialize those columns for potentially hundreds of entries.
		Or I may still want to look at invalid data that I never intended on including, like comment fields (which are named in ARMPs sometimes but never valid).

	- I will note: I am imagining that we are not automatically considering an empty column to be invalid.
		It is true that a column with only empty values is usually marked invalid in an ARMP, but I assume that's only when writing the binary.
		With the comment example above, I'm sure that RGG doesn't delete comments in an actual table prior to exporting an ARMP.


- Columns that aren't valid could have no member info, rather than having info with a negative position.

	- If a column that has no member info is invalid, and vice-versa, that creates a valuable default. (Storage Mode 1 only obviously.)

	- When an invalid column is marked valid, we could generate member info with the appropriate type.
		(I believe there are some weird corner cases with types that might invalidate this, I'd need to remind myself.)

	- When writing a binary file, a dummy entry with a negative position and the correct type could be written for invalid columns.


- Structure specifications could be editable with something like a list of sliding panels, one per ArmpMemberInfo.
	Something more complex like the struct editor in Ghidra could be good, but could also be overkill.

- It should be possible to save or load a structure specification as a file.

- It should be possible to create or load a structure specification without matching columns being present in a table,
	then automatically create columns in the table to match.

- There should be an option for ArmpMemberInfo in a spec to have manually-edited positions (currently LibARMP automatically packs structures).

- The same structure specification should be able to be connected to multiple tables at once. I haven't put any thought into how, exactly.
	But shared structures crop up a lot. One example is that any time a table has a table-type column, each entry's table in that column
	will share the same structure. Even though each table will have its own member info section, they will all be identical.

	A deeper example: if I wanted to create a brand-new UI file, I'd want essentially a template for that file type, because it will always be
	the main table containing a particular table-type column (you could think of this as actually being a struct-type column) with a structure spec
	identical to other files of this same type, and that structure will contain other structures identical to other files of the same type, and so on.


- SetStorageMode only goes one layer deep, but the comment specifies only to call it on the main table.
	Shouldn't it contain recursive calls if the goal is for every subtable of a subtable to have its storage mode changed?
	Mind you, I don't think there's any reason that a sub-table can't be a different storage mode than its parent, even though RGG don't do it.


When the storage mode of a table is changed:

	- From Structured: ask if the user wants to save the structure spec as a file, perhaps, then clear the structure.
		(The structure could be kept in memory and simply not used, to avoid unnecessary work and destruction of data.)

	- To Structured: create member info for every valid column, ordered by column.
		(If there's not already member info because of the prior note.)




I will also point out that if there's no interest in implementing the above structure spec goals, then ArmpMemberInfo doesn't need to exist.

	- The ordered list of ArmpMemberInfo in ArmpTableBase could instead be an ordered list of only the valid ArmpTableColumns.

	- The type of ArmpMemberInfo is mostly recoverable from the column's type. (Again, I think I recall weird cases here.)

	- The array size field is recoverable from the count of the Children list, which is already owned by the column.

	- The position field can be recovered by the order of the columns and their types, if we assume that the structure should always be packed.