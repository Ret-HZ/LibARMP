LibARMP / dbedit Notes:


- A column being marked invalid shouldn't delete its data.

	- If I mark a column invalid and its data is deleted, why wouldn't I just delete the column altogether?
		I'd think that I'd only mark a column invalid if I still want to retain it, which means the data is still potentially valuable.
		(I imagine the column greyed out but with the data still present, maybe even still editable.)

	- One example use case would be columns that I sometimes mark valid prior to export for debug purposes.
		I'd want them to still contain data, I wouldn't want to have to reinitialize those columns for potentially hundreds of entries.
		Or I may still want to look at invalid data that I never intended on including, like comment fields (which are named in ARMPs sometimes but never valid).

	- I will note: I am imagining that we are not automatically considering an empty column to be invalid.
		It is true that a column with only empty values is usually marked invalid in an ARMP, but I assume that's only when writing the binary.
		With the comment example above, I'm sure that RGG doesn't delete comments in an actual table prior to exporting an ARMP.


- Columns that aren't valid could have no member info, rather than having info with a negative position.

	- If a column that has no member info is invalid, and vice-versa, that creates a valuable default. (Storage Mode 1 only obviously.)

	- When an invalid column is marked valid, we could generate member info with the appropriate type.
		(There are some cases where the type used for storage in the member info is different from the actual value being stored.
		 For example, arena_deck_slot in Gaiden stores bytes in an int array, meaning each byte occupies four bytes.)

	- When writing a binary file, a dummy entry with a negative position and the correct type could be written for invalid columns.


- Structure specifications could be editable with something like a list of sliding panels, one per ArmpMemberInfo.
	Something more complex like the struct editor in Ghidra could be good, but could also be overkill.

- It should be possible to save or load a structure specification as a file.

- It should be possible to create or load a structure specification without matching columns being present in a table,
	then automatically create columns in the table to match.

- There should be an option for ArmpMemberInfo in a spec to have manually-edited positions (currently LibARMP automatically packs structures).
	Some files have very unique member info. In Gaiden, arena_deck_slot has a funky array as mentioned above.
	Another file in Gaiden is asset_icon, which has a valid column with a negative position in member info.


- The same structure specification should be able to be connected to multiple tables at once. I haven't put any thought into how, exactly.
	But shared structures crop up a lot. One example is that any time a table has a table-type column, each entry's table in that column
	will share the same structure. Even though each table will have its own member info section, they will all be identical.

	A deeper example: if I wanted to create a brand-new UI file, I'd want essentially a template for that file type, because it will always be
	the main table containing a particular table-type column (you could think of this as actually being a struct-type column) with a structure spec
	identical to other files of this same type, and that structure will contain other structures identical to other files of the same type, and so on.


When the storage mode of a table is changed:

	- From Structured: ask if the user wants to save the structure spec as a file, perhaps, then clear the structure.
		(The structure could be kept in memory and simply not used, to avoid unnecessary work and destruction of data.)

	- To Structured: create member info for every valid column, ordered by column.
		(If there's not already member info because of the prior note.)